{"version":3,"sources":["logo.svg","vrm/AIAvatar.js","App.js","reportWebVitals.js","index.js"],"names":["AIWorld","props","g","ga","rotations","limits","headBones","VRMSchema","HumanoidBoneName","Hips","Spine","Chest","UpperChest","Neck","Head","leftEyeBones","LeftEye","rightEyeBones","RightEye","leftHandBones","LeftShoulder","LeftUpperArm","LeftLowerArm","LeftHand","rightHandBones","RightShoulder","RightUpperArm","RightLowerArm","RightHand","leftFootBones","LeftUpperLeg","LeftLowerLeg","LeftFoot","LeftToes","rightFootBones","RightUpperLeg","RightLowerLeg","RightFoot","RightToes","body","onCanvasLoaded","canvas","currentVrm","setState","renderer","THREE","antialias","alpha","debug","setSize","clientWidth","clientHeight","setPixelRatio","window","devicePixelRatio","document","appendChild","domElement","camera","position","set","controls","OrbitControls","screenSpacePanning","target","update","scene","light","normalize","add","world","CANNON","World","gravity","broadphase","NaiveBroadphase","solver","iterations","tolerance","createGround","loadModel","gridHelper","axesHelper","animate","undefined","clock","bodies","vx","count","firstable","state","bind","groundMat","Material","groundShape","Plane","groundBody","Body","mass","material","addShape","quaternion","setFromAxisAngle","Vec3","Math","PI","addBody","GLTFLoader","load","gltf","VRM","from","then","vrm","console","log","humanoid","getBoneNode","rotation","y","x","lookAt","autoUpdate","constructBody","createObjectBody","progress","loaded","total","error","Object","keys","this","key","createObjectBone","parent","depth","children","co2key","node","name","createObject","pos","z","pname","d","distanceTo","Sphere","updateObject","updateObjectBone","ppos","npos","pv","nv","sub","multiplyScalar","v","p","min","getMinY","max","getWorldPosition","s","sin","elapsedTime","rotateOne","includes","dstx","randomR","dsty","dstz","current","dx","dy","dz","abs","fallModel","axis","limitX","random","multiply","setRotationFromQuaternion","l","u","humanBones","bones","length","setBoneInBody","treeBone","infoBone","bone","entries","forEach","value","b","blendShapeProxy","time","requestAnimationFrame","deltaTime","getDelta","pose","step","render","id","style","pointerEvents","zIndex","bottom","right","width","height","ref","co","cname","spineJoint","DistanceConstraint","addConstraint","targetBone","coco","createJoint","React","Component","App","className","src","logo","alt","href","rel","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.9ed6bd95.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React from 'react';\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { VRM, VRMSchema } from '@pixiv/three-vrm';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\r\nimport CANNON, { IContactMaterialOptions, Shape, Vec3 } from \"cannon\";\r\n\r\n// https://threejsfundamentals.org/threejs/lessons/threejs-cleanup.html\r\nclass ResourceTracker {\r\n    constructor() {\r\n        this.resources = new Set();\r\n    }\r\n    track(resource) {\r\n        if (resource.dispose || resource instanceof THREE.Object3D) {\r\n            this.resources.add(resource);\r\n        }\r\n        return resource;\r\n    }\r\n    untrack(resource) {\r\n        this.resources.delete(resource);\r\n    }\r\n    dispose() {\r\n        for (const resource of this.resources) {\r\n            if (resource instanceof THREE.Object3D) {\r\n                if (resource.parent) {\r\n                    resource.parent.remove(resource);\r\n                }\r\n            }\r\n            if (resource.dispose) {\r\n                resource.dispose();\r\n            }\r\n        }\r\n        this.resources.clear();\r\n    }\r\n}\r\n\r\nclass AIAvatar {\r\n\r\n}\r\n\r\nexport default class AIWorld extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            canvas: null\r\n        };\r\n        this.animate = this.animate.bind(this);\r\n    }\r\n\r\n    // Create a plane\r\n    createGround(world) {\r\n        // Plane Materialの質量定義\r\n        var groundMat = new CANNON.Material('groundMat');\r\n        var groundShape = new CANNON.Plane();\r\n        var groundBody = new CANNON.Body({\r\n            mass: 0,\r\n            material: groundMat\r\n        });\r\n        groundBody.addShape(groundShape);\r\n        // 90度回転してy=0平面にする\r\n        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);\r\n        groundBody.position.set(0, -1, 0);\r\n        world.addBody(groundBody);\r\n    }\r\n\r\n    loadModel() {\r\n        const loader = new GLTFLoader();\r\n        loader.load(\r\n\r\n            // URL of the VRM you want to load\r\n            '/vrm/three-vrm-girl.vrm',\r\n            // '/vrm/elmiku-v4x-0.8.vrm',\r\n\r\n            // called when the resource is loaded\r\n            (gltf) => {\r\n\r\n                // generate a VRM instance from gltf\r\n                VRM.from(gltf).then((vrm) => {\r\n\r\n                    console.log(vrm);\r\n\r\n                    // add the loaded vrm to the scene\r\n                    this.scene.add(vrm.scene);\r\n                    this.currentVrm = vrm;\r\n\r\n                    // カメラの方を向く\r\n                    vrm.humanoid.getBoneNode(VRMSchema.HumanoidBoneName.Hips).rotation.y = Math.PI;\r\n\r\n                    // -X象限に移動\r\n                    vrm.humanoid.getBoneNode(VRMSchema.HumanoidBoneName.Hips).position.x = 0;\r\n\r\n                    // camera:THREE.Camera 今回はOrbitControlsで操作しているカメラ \r\n                    vrm.lookAt.target = this.camera;\r\n\r\n                    // 目線をターゲットに追従させ更新する\r\n                    vrm.lookAt.autoUpdate = true;\r\n\r\n                    // ボーンを階層化する\r\n                    this.constructBody();\r\n                    console.log(this.body);\r\n\r\n                    // 階層化されたボーンをたどる\r\n                    this.createObjectBody();\r\n\r\n                    // this.updateObject(VRMSchema.HumanoidBoneName.Hips);\r\n\r\n                    // // IKのセットアップ\r\n                    // this.ik = new IK();\r\n                    // this.ik.isIK = true;\r\n\r\n                    // this.movingTarget = new THREE.Mesh(\r\n                    //     new THREE.SphereBufferGeometry(0.1),\r\n                    //     new THREE.MeshBasicMaterial({ color: 0xff0000 })\r\n                    // );\r\n                    // this.movingTarget.position.z = 2;\r\n\r\n                    // const chain = new IKChain();\r\n                    // const constraints = [new IKBallConstraint(90)];\r\n                    // let bone;\r\n                    // for (let i = 0; i < this.leftHandBones.length - 1; i++) {\r\n                    //     bone = this.getBoneNode(this.leftHandBones[i]);\r\n                    //     let target = null;\r\n                    //     if (i === this.leftHandBones.length - 2) {\r\n                    //         target = this.getBoneNode(this.leftHandBones[i + 1]);\r\n                    //     }\r\n                    //     chain.add(new IKJoint(bone, { constraints }), { target });\r\n                    // }\r\n\r\n                    // // Add the chain to the IK system\r\n                    // this.ik.add(chain);\r\n                });\r\n\r\n            },\r\n\r\n            // called while loading is progressing\r\n            (progress) => console.log('Loading model...', 100.0 * (progress.loaded / progress.total), '%'),\r\n\r\n            // called when loading has errors\r\n            (error) => console.error(error)\r\n\r\n        );\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////\r\n    // ボーンのオブジェクト化処理\r\n    ///////////////////////////////////////////////////////////////////\r\n\r\n    createObjectBody() {\r\n        // this.bodyから対象のボーンを見つける\r\n        for (const key of Object.keys(this.body)) {\r\n            this.createObjectBone(this.body[key], 0);\r\n        }\r\n    }\r\n\r\n    createObjectBone(parent, depth) {\r\n        if (parent) {\r\n            for (const co2key of Object.keys(parent.children)) {\r\n                const node = parent.children[co2key];\r\n                const name = node[\"name\"];\r\n                this.createObject(parent, name);\r\n                this.createObjectBone(node, depth + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    // オブジェクトをつくる\r\n    createObject(parent, name) {\r\n        if (!this.bodies[name]) {\r\n            const pos = this.getBoneNode(name).position;\r\n            var position = new CANNON.Vec3(pos.x, pos.y, pos.z);\r\n            const pname = parent[\"name\"];\r\n            let d = 1;\r\n            if (pname) {\r\n                // 親までの距離\r\n                d = pos.distanceTo(this.getBoneNode(pname).position);\r\n            }\r\n            var body = new CANNON.Body({\r\n                mass: 0,\r\n                position: position,\r\n                material: new CANNON.Material('groundMat'),\r\n            });\r\n            body.addShape(new CANNON.Sphere(0.001));\r\n            this.world.addBody(body);\r\n\r\n            body[\"d\"] = d;\r\n            this.bodies[name] = body;\r\n        }\r\n        this.updateObject(name);\r\n    }\r\n\r\n    updateObjectBody() {\r\n        // this.bodyから対象のボーンを見つける\r\n        for (const key of Object.keys(this.body)) {\r\n            this.updateObjectBone(this.body[key], 0);\r\n        }\r\n    }\r\n\r\n    updateObjectBone(parent, depth) {\r\n        if (parent) {\r\n            for (const co2key of Object.keys(parent.children)) {\r\n                const node = parent.children[co2key];\r\n                const name = node[\"name\"];\r\n                this.updateObject(parent, name);\r\n                this.updateObjectBone(node, depth + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateObject(parent, name) {\r\n        const pname = parent[\"name\"];\r\n        if (pname) {\r\n            const ppos = this.getBoneNode(pname).position;\r\n            const pos = this.getBoneNode(name).position;\r\n            const npos = this.bodies[name].position;\r\n\r\n            // 長さを維持するように動く\r\n            const d = this.bodies[name].d;\r\n            const pv = new THREE.Vector3(ppos.x, ppos.y, ppos.z);\r\n            let nv = new THREE.Vector3(npos.x, npos.y, npos.z);\r\n            nv = nv.sub(pv);\r\n            nv = nv.normalize();\r\n            nv = nv.multiplyScalar(d);\r\n\r\n            // this.bodies[name].position.set(nv.x, nv.y, nv.z);            \r\n            // this.getBoneNode(name).position.copy(this.bodies[name].position);\r\n\r\n            // if (name === VRMSchema.HumanoidBoneName.RightHand) {\r\n            //     console.log(this.getBoneNode(name))\r\n            // }\r\n\r\n            // 方向に向けて回転を制御する(うまくいってるっぽい)\r\n            // this.getBoneNode(name).quaternion.setFromUnitVectors(pos, ppos);\r\n        }\r\n    }\r\n\r\n    moveModel(v) {\r\n        const p = this.getBoneNode(VRMSchema.HumanoidBoneName.Hips).position;\r\n        p.x += v.x;\r\n        p.y += v.y;\r\n        p.z += v.z;\r\n        this.getBoneNode(VRMSchema.HumanoidBoneName.Hips).position.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    g = 0;\r\n    ga = 0.01;\r\n\r\n    fallModel(v) {\r\n        // 地面から浮いていたら重力を適用\r\n        let min = this.getMinY();\r\n        let p = this.getBoneNode(VRMSchema.HumanoidBoneName.Hips).position;\r\n        if (min > 0) {\r\n            this.g -= this.ga;\r\n            p.y += this.g;\r\n        }\r\n        this.getBoneNode(VRMSchema.HumanoidBoneName.Hips).position.set(p.x, p.y, p.z);\r\n\r\n        min = this.getMinY();\r\n        p = this.getBoneNode(VRMSchema.HumanoidBoneName.Hips).position;\r\n        if (min < 0) {\r\n            // 地面に埋め込んだら地面に戻す\r\n            p.y += -min;\r\n            this.g = 0;\r\n        }\r\n        this.getBoneNode(VRMSchema.HumanoidBoneName.Hips).position.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    getMinY() {\r\n        let max = 1;\r\n        for (let key of Object.keys(this.limits)) {\r\n            var target = new THREE.Vector3()\r\n            this.getBoneNode(key).getWorldPosition(target);\r\n            if (target.y <= 0) {\r\n                if (target.y < max) {\r\n                    max = target.y;\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    moveObject(name, v) {\r\n        const p = this.bodies[name].position;\r\n        p.x += v.x;\r\n        p.y += v.y;\r\n        p.z += v.z;\r\n        this.bodies[name].position.set(p.x, p.y, p.z);\r\n\r\n        // // 親に向かって移動\r\n        // // 子に向かって移動\r\n        // for (const key of Object.keys(this.bodies)) {\r\n        //     if (key !== name) {\r\n        //         const node = this.bodies[key];\r\n        //         const r = 0.5;\r\n        //         const p = node.position;\r\n        //         p.x += v.x * r;\r\n        //         p.y += v.y * r;\r\n        //         p.z += v.z * r;\r\n        //         node.position.set(p.x, p.y, p.z);\r\n        //     }\r\n        // }\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////\r\n    // ボーンのオブジェクト化処理\r\n    ///////////////////////////////////////////////////////////////////\r\n\r\n    poseDebug() {\r\n        const s = 1 * Math.PI * Math.sin(Math.PI * this.clock.elapsedTime);\r\n        let key = \"hips\";\r\n        let node = this.getBoneNode(key);\r\n        // node.rotation.y = s;\r\n        // key = \"rightShoulder\";\r\n        // node = this.getBoneNode(key);\r\n        // node.rotation.y = this.limitX(key, \"y\", s);\r\n        // node.rotation.x = this.limitX(key, \"x\", s);\r\n        this.rotateOne(\"rightUpperArm\", s, 0, 0);\r\n        this.rotateOne(\"leftUpperArm\", s, 0, 0);\r\n        this.rotateOne(\"leftLowerArm\", s, 0, 0);\r\n        // this.rotateOne(\"rightLowerArm\",s, 0, 0);\r\n        // this.rotateOne(\"upperChest\", s, 0, 0);\r\n        // this.rotateOne(\"chest\", s, 0, 0);\r\n        // this.rotateOne(\"spine\", s, 0, 0);\r\n        // this.rotateOne(\"leftUpperLeg\", -s, 0, 0);\r\n        // this.rotateOne(\"rightUpperLeg\", -s, 0, 0);\r\n        // this.rotateOne(\"leftShoulder\", s, s, s);\r\n        // this.rotateOne(\"rightShoulder\", s, s, s);\r\n\r\n        // key = \"chest\";\r\n        // node = this.getBoneNode(key);\r\n        // node.rotation.y = this.limitX(key, \"y\", s);\r\n        // key = \"spine\";\r\n        // node = this.getBoneNode(key);\r\n        // node.rotation.y = this.limitX(key, \"y\", s);\r\n        // key = \"leftUpperLeg\";\r\n        // node = this.getBoneNode(key);\r\n        // node.rotation.y = this.limitX(key, \"y\", -s);\r\n        // key = \"rightUpperLeg\";\r\n        // node = this.getBoneNode(key);\r\n        // node.rotation.y = this.limitX(key, \"y\", -s);\r\n    }\r\n\r\n    rotations = {\r\n    }\r\n\r\n    pose() {\r\n        // this.poseDebug();\r\n        // return;\r\n        for (const key of Object.keys(this.bodies)) {\r\n            if (Object.keys(this.limits).includes(key)) {\r\n                if (!Object.keys(this.rotations).includes(key)) {\r\n                    // 最初の回転なら目的地を決める\r\n                    var limits = this.limits[key];\r\n                    let dstx = this.randomR(limits, \"x\")\r\n                    let dsty = this.randomR(limits, \"y\")\r\n                    let dstz = this.randomR(limits, \"z\")\r\n                    this.rotations[key] = [\r\n                        [0, 0, 0], // position\r\n                        [0, 0, 0], // velocity\r\n                        [dstx, dsty, dstz] // dst\r\n                    ];\r\n                }\r\n\r\n                // 現在地と目的地から移動量を決める\r\n                let v = 0.1;\r\n                let current = this.rotations[key];\r\n                let dx = current[0][0];\r\n                let dy = current[0][1];\r\n                let dz = current[0][2];\r\n                dx += (current[2][0] - dx) * v;\r\n                dy += (current[2][1] - dy) * v;\r\n                dz += (current[2][2] - dz) * v;\r\n\r\n                // 回転する\r\n                this.rotateOne(key, dx, dy, dz);\r\n\r\n                // 現在地を更新する\r\n                current[0][0] = dx;\r\n                current[0][1] = dy;\r\n                current[0][2] = dz;\r\n                if (Math.abs(current[2][0] - dx) < 0.01) {\r\n                    var limits = this.limits[key];\r\n                    let dstx = this.randomR(limits, \"x\")\r\n                    let dsty = this.randomR(limits, \"y\")\r\n                    let dstz = this.randomR(limits, \"z\")\r\n                    this.rotations[key] = [\r\n                        [dx, dy, dz], // position\r\n                        [0, 0, 0], // velocity\r\n                        [dstx, dsty, dstz] // dst\r\n                    ];\r\n                }\r\n            }\r\n        }\r\n\r\n        this.fallModel();\r\n    }\r\n\r\n    // 回転量を制限の範囲でランダムに決める\r\n    randomR(limits, axis) {\r\n        let min = this.limitX(limits, axis, -0.5 * Math.PI);\r\n        let max = this.limitX(limits, axis, 0.5 * Math.PI);\r\n        return Math.random() * (max - min) + min;\r\n    }\r\n\r\n    // 回転量をランダムに決める(MAX)\r\n    randomX(x) {\r\n        x = 0.5 * Math.PI * (Math.random() - 0.5) * 2;\r\n        return x;\r\n    }\r\n\r\n    // 関節可動域\r\n    limits = {\r\n        \"neck\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0.2, 0.3], // -が前\r\n            \"y\": [-0.2, 0.2],\r\n            \"z\": [-0.2, 0.2],\r\n        },\r\n        \"upperChest\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0.2, 0.1], // -が前\r\n            \"y\": [-0.1, 0.1],\r\n            \"z\": [-0.1, 0.1],\r\n        },\r\n        \"chest\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0.2, 0.1], // -が前\r\n            \"y\": [-0.1, 0.1],\r\n            \"z\": [-0.1, 0.1],\r\n        },\r\n        \"spine\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0.1, 0.1], // -が前\r\n            \"y\": [-0.1, 0.1],\r\n            \"z\": [-0.1, 0.1],\r\n        },\r\n        \"leftShoulder\": {\r\n            \"axis\": \"x\",\r\n            \"x\": [-0, 0], // -が後ろ\r\n            \"y\": [-0, 0], // +が前\r\n            \"z\": [-0, 0],\r\n        },\r\n        \"rightShoulder\": {\r\n            \"axis\": \"x\",\r\n            \"x\": [-0, 0], // -が後ろ\r\n            \"y\": [-0, 0], // +が前\r\n            \"z\": [-0, 0],\r\n        },\r\n        \"leftUpperArm\": {\r\n            \"axis\": \"x\",\r\n            \"x\": [-0.25, 0.5], // -が後ろ\r\n            \"y\": [-0.75, 0.25],\r\n            \"z\": [-0.25, 0.25],\r\n        },\r\n        \"leftLowerArm\": {\r\n            \"axis\": \"x\",\r\n            \"x\": [-0.5, 0.5], // -が後ろ\r\n            \"y\": [-0.75, 0],\r\n            \"z\": [-0, 0.75],\r\n        },\r\n        \"rightUpperArm\": {\r\n            \"axis\": \"x\",\r\n            \"x\": [-0.25, 0.5], // -が後ろ\r\n            \"y\": [-0.25, 0.75],\r\n            \"z\": [-0.25, 0.25],\r\n        },\r\n        \"rightLowerArm\": {\r\n            \"axis\": \"x\",\r\n            \"x\": [-0.5, 0.5], // -が後ろ\r\n            \"y\": [-0, 0.75],\r\n            \"z\": [-0.75, 0],\r\n        },\r\n\r\n        \"leftUpperLeg\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0, 0.75], // 前のみ\r\n            \"y\": [-0.25, 0.25], // ねじり\r\n            \"z\": [-0.25, 0.25],\r\n        },\r\n        \"rightUpperLeg\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0, 0.75], // 前のみ\r\n            \"y\": [-0.25, 0.25], // ねじり\r\n            \"z\": [-0.25, 0.25],\r\n        },\r\n        \"leftLowerLeg\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0.75, 0], // 後ろのみ\r\n            \"y\": [-0.25, 0.25], // ねじり\r\n            \"z\": [-0, 0],\r\n        },\r\n        \"rightLowerLeg\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0.75, 0], // 後ろのみ\r\n            \"y\": [-0.25, 0.25], // ねじり\r\n            \"z\": [-0, 0],\r\n        },\r\n        \"leftToes\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0, 0], // 後ろのみ\r\n            \"y\": [-0, 0], // ねじり\r\n            \"z\": [-0, 0],\r\n        },\r\n        \"rightToes\": {\r\n            \"axis\": \"y\",\r\n            \"x\": [-0, 0], // 後ろのみ\r\n            \"y\": [-0, 0], // ねじり\r\n            \"z\": [-0, 0],\r\n        },\r\n        // \"hips\": {\r\n        //     \"x\": [-1, 1],\r\n        //     \"y\": [-1, 1],\r\n        //     \"z\": [-1, 1],\r\n        // }\r\n    }\r\n\r\n    headBones = [\r\n        VRMSchema.HumanoidBoneName.Hips,\r\n        VRMSchema.HumanoidBoneName.Spine,\r\n        VRMSchema.HumanoidBoneName.Chest,\r\n        VRMSchema.HumanoidBoneName.UpperChest,\r\n        VRMSchema.HumanoidBoneName.Neck,\r\n        VRMSchema.HumanoidBoneName.Head,\r\n    ];\r\n    leftEyeBones = [\r\n        VRMSchema.HumanoidBoneName.Head,\r\n        VRMSchema.HumanoidBoneName.LeftEye,\r\n    ];\r\n    rightEyeBones = [\r\n        VRMSchema.HumanoidBoneName.Head,\r\n        VRMSchema.HumanoidBoneName.RightEye,\r\n    ];\r\n    leftHandBones = [\r\n        VRMSchema.HumanoidBoneName.UpperChest,\r\n        VRMSchema.HumanoidBoneName.LeftShoulder,\r\n        VRMSchema.HumanoidBoneName.LeftUpperArm,\r\n        VRMSchema.HumanoidBoneName.LeftLowerArm,\r\n        VRMSchema.HumanoidBoneName.LeftHand,\r\n    ];\r\n    rightHandBones = [\r\n        VRMSchema.HumanoidBoneName.UpperChest,\r\n        VRMSchema.HumanoidBoneName.RightShoulder,\r\n        VRMSchema.HumanoidBoneName.RightUpperArm,\r\n        VRMSchema.HumanoidBoneName.RightLowerArm,\r\n        VRMSchema.HumanoidBoneName.RightHand,\r\n    ];\r\n    leftFootBones = [\r\n        VRMSchema.HumanoidBoneName.Hips,\r\n        VRMSchema.HumanoidBoneName.LeftUpperLeg,\r\n        VRMSchema.HumanoidBoneName.LeftLowerLeg,\r\n        VRMSchema.HumanoidBoneName.LeftFoot,\r\n        VRMSchema.HumanoidBoneName.LeftToes,\r\n    ];\r\n    rightFootBones = [\r\n        VRMSchema.HumanoidBoneName.Hips,\r\n        VRMSchema.HumanoidBoneName.RightUpperLeg,\r\n        VRMSchema.HumanoidBoneName.RightLowerLeg,\r\n        VRMSchema.HumanoidBoneName.RightFoot,\r\n        VRMSchema.HumanoidBoneName.RightToes,\r\n    ];\r\n\r\n    // ボーンを回転する\r\n    // 特定の順番で軸回転しないとおかしくなる\r\n    // クオータニオンを使って回転する\r\n    rotateOne(key, x, y, z) {\r\n        if (!Object.keys(this.limits).includes(key)) {\r\n            return;\r\n        }\r\n        var limits = this.limits[key];\r\n        var axis = limits['axis'];\r\n        var node = this.getBoneNode(key);\r\n        var quaternion = new THREE.Quaternion();\r\n        var target = new THREE.Quaternion();\r\n        if (axis === \"x\") {\r\n            target.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.limitX(limits, \"y\", y));\r\n            quaternion.multiply(target);\r\n            target = new THREE.Quaternion();\r\n            target.setFromAxisAngle(new THREE.Vector3(0, 0, 1), this.limitX(limits, \"z\", z));\r\n            quaternion.multiply(target);\r\n            target = new THREE.Quaternion();\r\n            target.setFromAxisAngle(new THREE.Vector3(1, 0, 0), this.limitX(limits, \"x\", x));\r\n            quaternion.multiply(target);\r\n        } else { // y\r\n            target.setFromAxisAngle(new THREE.Vector3(1, 0, 0), this.limitX(limits, \"x\", x));\r\n            quaternion.multiply(target);\r\n            target = new THREE.Quaternion();\r\n            target.setFromAxisAngle(new THREE.Vector3(0, 0, 1), this.limitX(limits, \"z\", z));\r\n            quaternion.multiply(target);\r\n            target = new THREE.Quaternion();\r\n            target.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.limitX(limits, \"y\", y));\r\n            quaternion.multiply(target);\r\n        }\r\n        node.setRotationFromQuaternion(quaternion);\r\n    }\r\n\r\n    limitX(limits, axis, x) {\r\n        let l = limits[axis][0] * 1 * Math.PI;\r\n        let u = limits[axis][1] * 1 * Math.PI;\r\n        if (x < l) x = l;\r\n        if (x > u) x = u;\r\n        return x;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////\r\n    // ボーンの階層化処理\r\n    ///////////////////////////////////////////////////////////////////\r\n\r\n    // ボーンの階層構造\r\n    body = {};\r\n\r\n    // ボディを階層化する\r\n    constructBody() {\r\n        // ボディにボーンをセットする\r\n        for (const key of Object.keys(this.currentVrm.humanoid.humanBones)) {\r\n            const bones = this.currentVrm.humanoid.humanBones[key];\r\n            if (bones && bones.length > 0) {\r\n                this.setBoneInBody(bones[0].node.parent, bones[0].node);\r\n            }\r\n        }\r\n\r\n        // 仮親ボーンが子ボーンリストに存在したら、親から外して子ボーンリストにつける\r\n        for (const name of Object.keys(this.body)) {\r\n            for (const key of Object.keys(this.body)) {\r\n                this.treeBone(this.body[key], name);\r\n            }\r\n        }\r\n\r\n        // 階層化したボーンにボーン情報を付加する\r\n        // 親ボーンへの距離を保持する\r\n        // IKを処理するときにこの距離を維持するようにする\r\n        for (const key of Object.keys(this.body)) {\r\n            this.infoBone(this.body[key]);\r\n        }\r\n    }\r\n\r\n    // ボディにボーンをセットする\r\n    setBoneInBody(parent, bone) {\r\n        if (!(parent.name in this.body)) {\r\n            this.body[parent.name] = { children: {} };\r\n        }\r\n        this.body[parent.name].node = parent\r\n        this.body[parent.name].children[bone.name] = { node: bone, children: {} };\r\n    }\r\n\r\n    // 仮親ボーンが子ボーンリストに存在したら、親から外して子ボーンリストにつける\r\n    treeBone(parent, name) {\r\n        if (parent) {\r\n            const children = parent.children;\r\n            for (const co2key of Object.keys(children)) {\r\n                // 子と一致したらそこに移動\r\n                if (co2key === name) {\r\n                    children[co2key] = this.body[name];\r\n                    delete this.body[name];\r\n                    return;\r\n                }\r\n                // さらに探索\r\n                this.treeBone(children[co2key], name);\r\n            }\r\n        }\r\n    }\r\n\r\n    // HumanoidBoneNameと対応付ける\r\n    infoBone(parent) {\r\n        if (parent) {\r\n            const pnode = parent.node;\r\n            const children = parent.children;\r\n            for (const co2key of Object.keys(children)) {\r\n                // 親ボーンとの距離を算出\r\n\r\n                // 名前の対応付け\r\n                Object.entries(VRMSchema.HumanoidBoneName).forEach(([key, value]) => {\r\n                    const b = this.getBoneNode(value);\r\n                    if (b && children[co2key].node.name === b.name) {\r\n                        children[co2key][\"name\"] = value;\r\n                    }\r\n                });\r\n\r\n                // 子ボーンを処理\r\n                this.infoBone(children[co2key])\r\n            }\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////\r\n    // 3Dワールドの初期化\r\n    ///////////////////////////////////////////////////////////////////\r\n\r\n    onCanvasLoaded = (canvas) => {\r\n        if (!canvas) {\r\n            return;\r\n        }\r\n\r\n        if (this.currentVrm) {\r\n            return;\r\n        }\r\n\r\n        this.setState({ canvas: canvas });\r\n\r\n        // renderer\r\n        this.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: !this.props.debug ? true : false });\r\n        this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);\r\n        this.renderer.setPixelRatio(window.devicePixelRatio);\r\n        document.body.appendChild(this.renderer.domElement);\r\n\r\n        // camera\r\n        this.camera = new THREE.PerspectiveCamera(30.0, canvas.clientWidth / canvas.clientHeight, 0.1, 500.0);\r\n        this.camera.position.set(0.0, 0.0, 10.0);\r\n\r\n        // camera controls\r\n        const controls = new OrbitControls(this.camera, this.renderer.domElement);\r\n        controls.screenSpacePanning = true;\r\n        controls.target.set(0.0, 0.0, 0.0);\r\n        controls.update();\r\n\r\n        // scene\r\n        this.scene = new THREE.Scene();\r\n\r\n        // light\r\n        const light = new THREE.DirectionalLight(0xffffff);\r\n        light.position.set(1.0, 1.0, 1.0).normalize();\r\n        this.scene.add(light);\r\n\r\n        // Setup our world\r\n        this.world = new CANNON.World();\r\n        this.world.gravity.set(0, -9.82, 0); // m/s²\r\n        this.world.gravity.set(0, -0.982, 0); // m/s²\r\n        // ぶつかっている「可能性のある」剛体同士を見つける作業\r\n        this.world.broadphase = new CANNON.NaiveBroadphase();\r\n        // 反復計算回数\r\n        this.world.solver.iterations = 5;\r\n        // 許容値\r\n        this.world.solver.tolerance = 0.1;\r\n\r\n        // 地面を作る\r\n        this.createGround(this.world);\r\n\r\n        // モデルをロードする\r\n        this.loadModel();\r\n\r\n        if (this.props.debug) {\r\n            // helpers\r\n            const gridHelper = new THREE.GridHelper(10, 10);\r\n            this.scene.add(gridHelper);\r\n\r\n            const axesHelper = new THREE.AxesHelper(5);\r\n            this.scene.add(axesHelper);\r\n        }\r\n\r\n        this.animate(0);\r\n    };\r\n\r\n    ///////////////////////////////////////////////////////////////////\r\n    // \r\n    ///////////////////////////////////////////////////////////////////\r\n\r\n    // animate\r\n    // ik = undefined;\r\n    camera = undefined;\r\n    scene = undefined;\r\n    renderer = undefined;\r\n    currentVrm = undefined;\r\n    clock = new THREE.Clock();\r\n\r\n    // movingTarget = undefined;\r\n\r\n    getBoneNode(name) {\r\n        return this.currentVrm.humanoid.getBoneNode(name);\r\n    }\r\n\r\n    getBlendShapeProxy() {\r\n        return this.currentVrm.blendShapeProxy;\r\n    }\r\n\r\n    // fixedTimeStep = 1.0 / 60.0; // seconds\r\n    // maxSubSteps = 3;\r\n    // lastTime = undefined;\r\n\r\n    // Cannon\r\n    bodies = {};\r\n    vx = -0.01;\r\n    count = 0;\r\n\r\n    animate(time) {\r\n        window.requestAnimationFrame(this.animate);\r\n\r\n        // if (this.lastTime !== undefined) {\r\n        //     var dt = (time - this.lastTime) / 1000;\r\n        //     this.world.step(this.fixedTimeStep, dt, this.maxSubSteps);\r\n        // }\r\n        // console.log(\"Sphere z position: \" + this.sphereBody.position.z);\r\n        // this.lastTime = time;\r\n\r\n        const deltaTime = this.clock.getDelta();\r\n\r\n        if (this.currentVrm) {\r\n            this.pose();\r\n\r\n            this.currentVrm.update(deltaTime);\r\n            if (this.world) {\r\n                this.world.step(deltaTime);\r\n            }\r\n\r\n            // this.moveObject(VRMSchema.HumanoidBoneName.RightHand, new THREE.Vector3(0, this.vx, 0))\r\n            // this.moveObject(VRMSchema.HumanoidBoneName.RightHand, new THREE.Vector3(0, 0, this.vx))\r\n            // const p = this.getBoneNode(VRMSchema.HumanoidBoneName.RightHand).position;\r\n            // // const p = this.bodies[VRMSchema.HumanoidBoneName.RightHand].position;\r\n            // p.x += this.vx;\r\n            // if (p.x < -5 || p.x > 0) {\r\n            //     this.vx = -this.vx;\r\n            // }\r\n            // // this.getBoneNode(VRMSchema.HumanoidBoneName.RightHand).position.set(p.x, p.y, p.z);\r\n            // this.getBoneNode(VRMSchema.HumanoidBoneName.RightHand).position.set(p.x, p.y, p.z);\r\n\r\n            // // bones\r\n            // const s = 0.45 * Math.PI * Math.sin(Math.PI * this.clock.elapsedTime);\r\n            // this.moveModel(new THREE.Vector3(s * 0.01,0,0));\r\n            // this.getBoneNode(VRMSchema.HumanoidBoneName.Hips).rotation.y = s * 2;\r\n            // this.getBoneNode(VRMSchema.HumanoidBoneName.LeftUpperArm).rotation.z = s;\r\n            // this.getBoneNode(VRMSchema.HumanoidBoneName.RightUpperArm).rotation.z = -s;\r\n            // console.log(this.getBoneNode(VRMSchema.HumanoidBoneName.LeftLowerArm).position);\r\n\r\n            // if (this.world) {\r\n            //     // 物理演算の結果をモデルに反映する\r\n            //     this.updateObjectBody();\r\n            //     // this.doik();\r\n            //     // this.updateObject(VRMSchema.HumanoidBoneName.Hips);\r\n            //     // this.updateObject(VRMSchema.HumanoidBoneName.Chest);\r\n            // }\r\n\r\n            // blend shapes\r\n            // this.getBlendShapeProxy().setValue(VRMSchema.BlendShapePresetName.Fun, .7);\r\n            // this.getBlendShapeProxy().setValue(VRMSchema.BlendShapePresetName.Sorrow, .2);\r\n            // this.getBlendShapeProxy().update();\r\n\r\n            // 一定時間経過ごとにポーズを変える\r\n            // this.count += deltaTime;\r\n            // if (this.count > 3) {\r\n            //     this.count = 0;\r\n            //     this.pose();\r\n            // }\r\n\r\n            // this.movingTarget.position.x = px;\r\n            // IKの状態を更新する\r\n            // this.ik.solve();\r\n            // let target = this.getBoneNode(VRMSchema.HumanoidBoneName.RightHand).position;\r\n            // target.x += 0.01;\r\n            // this.doik(VRMSchema.HumanoidBoneName.LeftHand, target);\r\n        }\r\n\r\n        this.renderer.render(this.scene, this.camera);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <canvas id=\"canvas\"\r\n                style={{\r\n                    pointerEvents: this.props.debug ? \"auto\" : \"none\",\r\n                    zIndex: \"999\",\r\n                    position: \"fixed\",\r\n                    bottom: this.state.canvas ? -this.state.canvas.clientHeight / 2 + \"px\" : \"0px\",\r\n                    // right: this.state.canvas ? -this.state.canvas.clientWidth / 2 + \"px\" : \"0px\",\r\n                    right: \"0px\",\r\n                    width: \"100vw\",\r\n                    height: \"200vh\"\r\n                }}\r\n                ref={this.onCanvasLoaded} />\r\n        );\r\n    }\r\n\r\n    createJoint(parent, co) {\r\n        let pname = this.bodies[parent[\"name\"]];\r\n        let cname = this.bodies[co[\"name\"]];\r\n        let p = pname.position;\r\n        let c = cname.position;\r\n        console.log(pname, cname)\r\n        if (!pname || !cname) {\r\n            return;\r\n        }\r\n        const angleA = Math.PI / 4;\r\n        const angleB = Math.PI / 3;\r\n        const twistAngle = Math.PI / 8;\r\n        const pelvisLength = 0.4;\r\n\r\n        var spineJoint = new CANNON.DistanceConstraint(pname, cname, 0.1);\r\n        // var spineJoint = new CANNON.ConeTwistConstraint(pname, cname, {\r\n        //     pivotA: new CANNON.Vec3(0, pelvisLength / 2, 0),\r\n        //     pivotB: new CANNON.Vec3(0, -pelvisLength / 2, 0),\r\n        //     axisA: CANNON.Vec3.UNIT_Y,\r\n        //     axisB: CANNON.Vec3.UNIT_Y,\r\n        //     angle: angleA,\r\n        //     twistAngle: twistAngle\r\n        // });\r\n        this.world.addConstraint(spineJoint);\r\n    }\r\n\r\n    // 目標の動作をする\r\n    // どういう順番でどういう動きをしたらいいかを覚える\r\n    // まずは特定の部位を目標の場所へ移動させる、つまりIK\r\n    // FABRIKという手法がある。基本それにする。\r\n\r\n    // this.bodyにRootから全ボーンをセットした。\r\n    // pointを指定すると、それを移動する。\r\n    // pointにつながったボーンを上と下に向けて動かす。\r\n    // 基本はそのまま動かす。無重力空間っぽく。\r\n\r\n    doik() {\r\n        // this.bodyから対象のボーンを見つける\r\n        for (const key of Object.keys(this.body)) {\r\n            this.targetBone(this.body[key], 0);\r\n        }\r\n        this.firstable = false;\r\n    }\r\n\r\n    firstable = true;\r\n\r\n    targetBone(parent, depth) {\r\n        if (parent) {\r\n            for (const co2key of Object.keys(parent.children)) {\r\n                const node = parent.children[co2key];\r\n                const name = node[\"name\"];\r\n\r\n                // update\r\n                this.updateObject(name);\r\n\r\n                // 子ボーンを処理\r\n                if (depth < 2) {\r\n                    this.targetBone(node, depth + 1);\r\n                }\r\n\r\n                if (this.firstable) {\r\n                    // ジョイントを追加\r\n                    for (const coco of Object.keys(node.children)) {\r\n                        const co = node.children[coco];\r\n                        this.createJoint(node, co);\r\n                    }\r\n                }\r\n\r\n                // if (name === source) {\r\n                //     // 目的のボーンを見つけた\r\n                //     const bone = this.getBoneNode(name);\r\n\r\n                //     // 目的のボーンを移動する\r\n                //     // 差分をとる\r\n                //     const d = target - bone.position;\r\n                //     // 移動\r\n                //     const px = bone.position.x + d.x;\r\n                //     const py = bone.position.y + d.y;\r\n                //     const pz = bone.position.z + d.z;\r\n                //     bone.position.set(px, py, pz);\r\n\r\n                //     // つながっているボーンを距離が一定になるように移動する\r\n                //     // 親を１つずつ辿る\r\n                //     // 子を１つずつ辿る\r\n\r\n                //     // まず先端を全部くっつける(最後がくっつかなくなる)\r\n                //     // ただし、曲がらない方向にはいかない\r\n                //     // また曲がってもつらい方向の場合は痛みを増やす\r\n\r\n                //     // 次に根元をくっつける\r\n\r\n                //     // 先端→根本を繰り返し、収束させる\r\n\r\n                //     return;\r\n                // }\r\n            }\r\n        }\r\n    }\r\n}","import logo from './logo.svg';\r\nimport './App.css';\r\nimport AIWorld from './vrm/AIAvatar';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.js</code> and save to reload.\r\n        </p>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n      <AIWorld debug={true} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}